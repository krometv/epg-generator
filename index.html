<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML EPG Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 20px 20px 0 0;
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .content {
            padding: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }
        
        .control-group h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        
        button:hover {
            background: #5a67d8;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-info {
            background: #17a2b8;
        }
        
        #xmlOutput {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        
        .status.show {
            display: block;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        
        .stat-card h4 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .stat-card p {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.5em;
            }
            
            .button-grid {
                grid-template-columns: 1fr;
            }
            
            button {
                width: 100%;
            }
        }
        
        .loading {
            display: inline-block;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ XML EPG Generator</h1>
            <p>Generate Electronic Program Guide XML for Sports Events</p>
        </div>
        
        <div class="content">
            <div id="status" class="status"></div>
            
            <div class="control-group">
                <h3>üìù Event Input</h3>
                <label>Enter Events (Format: Channel ID :Event Name @ Date Time)</label>
                <textarea id="eventInput" placeholder="MLB 01 :Yankees vs Red Sox @ Sep 22 7:00 PM
Peacock Event 01 :World Athletics @ Sep 22 06:00 AM
NFL Game Pass 1 :Lions vs Bears @ Sep 22 1:00 PM
EFL01 :Chelsea vs Arsenal @ Sep 22 3:00 PM
MAX US01 :Cycling Tour @ Sep 22 9:00 AM"></textarea>
                <div class="button-grid" style="grid-template-columns: 1fr 1fr; margin-top: 10px;">
                    <button onclick="addEvents()" class="btn-success">Add Events to EPG</button>
                    <button onclick="clearInput()" class="btn-secondary">Clear Input</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üõ†Ô∏è EPG Management</h3>
                <div class="button-grid">
                    <button onclick="initChannels()" class="btn-primary">Initialize Fresh Channels</button>
                    <button onclick="loadAndAppend()" class="btn-warning">Load & Continue</button>
                    <button onclick="purgeOld()" class="btn-info">Purge Old (7+ days)</button>
                    <button onclick="clearAll()" class="btn-danger">Clear All</button>
                    <button onclick="showStatistics()" class="btn-secondary">Show Stats</button>
                </div>
                <div id="stats" class="stats" style="display: none;"></div>
            </div>
            
            <div class="control-group">
                <h3>üíæ GitHub Integration</h3>
                <label>GitHub Token (saved locally):</label>
                <input type="password" id="githubToken" placeholder="Enter GitHub Personal Access Token">
                <div class="button-grid" style="grid-template-columns: 1fr 1fr; margin-top: 10px;">
                    <button onclick="saveToken()" class="btn-info">Save Token</button>
                    <button onclick="saveToGitHub()" class="btn-success">üíæ Save EPG to GitHub</button>
                </div>
                <div id="saveStatus" style="margin-top: 10px;"></div>
            </div>
            
            <div class="control-group">
                <h3>Generated EPG XML:</h3>
                <button onclick="downloadXML()" class="btn-warning" style="margin-bottom: 10px;">üì• Download XML</button>
                <div id="xmlOutput">No EPG generated yet. Click "Initialize Fresh Channels" or "Load & Continue" to start.</div>
            </div>
        </div>
    </div>

<script>
// Global variables
let currentEPG = null;
const GITHUB_REPO = 'krometv/EPG';
const GITHUB_FILE = 'KTV_EPG_Events-all.xml';

// Channel configurations - FIXED WITH PROPER SPACING
const channelConfigs = [
    { prefix: 'MLB ', count: 30, sport: 'baseball' },          // MLB 01, MLB 02...
    { prefix: 'Peacock Event ', count: 100, sport: 'athletic' }, // Peacock Event 01...
    { prefix: 'NFL Game Pass ', count: 30, sport: 'football' },  // NFL Game Pass 1...
    { prefix: 'VIX+ ', count: 10, sport: 'soccer' },            // VIX+ 01...
    { prefix: 'BTN+ ', count: 100, sport: 'athletic' },         // BTN+ 01...
    { prefix: 'Paramount+ ', count: 100, sport: 'soccer' },     // Paramount+ 01...
    { prefix: 'Stan Sports ', count: 81, sport: 'rugby' },      // Stan Sports 01...
    { prefix: 'Milb ', count: 300, sport: 'baseball' },         // Milb 01...
    { prefix: 'ESPN+ ', count: 300, sport: 'athletic' },        // ESPN+ 01...
    { prefix: 'Flo Wrestling ', count: 100, sport: 'athletic' }, // Flo Wrestling 01...
    { prefix: 'Flo Hockey ', count: 300, sport: 'hockey' },     // Flo Hockey 01...
    { prefix: 'NHL ', count: 30, sport: 'hockey' },             // NHL 01...
    { prefix: 'Flo Baseball ', count: 100, sport: 'baseball' }, // Flo Baseball 01...
    { prefix: 'Flo Football ', count: 100, sport: 'football' }, // Flo Football 01...
    { prefix: 'Flo College ', count: 300, sport: 'athletic' },  // Flo College 01...
    { prefix: 'Flo Racing ', count: 50, sport: 'racing' },      // Flo Racing 01...
    { prefix: 'TSN+ ', count: 100, sport: 'athletic' },         // TSN+ 01...
    { prefix: 'WNBA ', count: 30, sport: 'basketball' },        // WNBA 01...
    { prefix: 'Tennis ', count: 150, sport: 'tennis' },         // Tennis 01...
    { prefix: 'MAX US', count: 300, sport: 'athletic' },        // MAX US01 (no space)
    { prefix: 'UEFA ', count: 20, sport: 'soccer' },            // UEFA 01...
    { prefix: 'Clubber Event ', count: 89, sport: 'athletic' }, // Clubber Event 01...
    { prefix: 'MLS ', count: 60, sport: 'soccer' },             // MLS 01...
    { prefix: 'EFL', count: 40, sport: 'soccer' },              // EFL01 (no space)
    { prefix: 'PPV ', count: 120, sport: 'athletic' },          // PPV 01...
    { prefix: 'Dirtvision ', count: 10, sport: 'racing' }       // Dirtvision 01...
];

// Initialize on load
window.onload = function() {
    const token = localStorage.getItem('githubToken');
    if (token) {
        document.getElementById('githubToken').value = token;
    }
    showStatus('Ready! Click "Initialize Fresh Channels" for new EPG or "Load & Continue" to add to existing.', 'info');
};

// Show status message
function showStatus(message, type) {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = 'status show ' + type;
    setTimeout(() => {
        status.classList.remove('show');
    }, 5000);
}

// Format date for XML
function formatDateForXML(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    const h = String(date.getHours()).padStart(2, '0');
    const min = String(date.getMinutes()).padStart(2, '0');
    const s = String(date.getSeconds()).padStart(2, '0');
    return `${y}${m}${d}${h}${min}${s} +0000`;
}

// Parse XML date
function parseXMLDate(xmlDate) {
    if (!xmlDate) return new Date();
    const match = xmlDate.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/);
    if (match) {
        return new Date(match[1], match[2]-1, match[3], match[4], match[5], match[6]);
    }
    return new Date();
}

// Initialize fresh channels with proper display names
function initChannels() {
    try {
        if (currentEPG && !confirm('This will replace ALL existing data with fresh channels. Continue?')) {
            return;
        }
        
        const programmes = [];
        const now = new Date();
        
        channelConfigs.forEach(config => {
            for (let i = 1; i <= config.count; i++) {
                const num = String(i).padStart(2, '0');
                // These channels have NO space before number
                const noSpaceChannels = ['MAX US', 'EFL'];
                let displayName;
                
                if (noSpaceChannels.some(ch => config.prefix.startsWith(ch))) {
                    displayName = config.prefix.trim() + num;  // No space
                } else {
                    displayName = config.prefix.trim() + ' ' + num;  // With space
                }
                
                const xmlId = displayName.replace(/[\s\-\.]+/g, '');
                
                programmes.push({
                    channel: xmlId,
                    displayName: displayName,
                    start: formatDateForXML(now),
                    stop: formatDateForXML(new Date(now.getTime() + 3600000)),
                    title: 'Channel Placeholder',
                    desc: 'Placeholder for ' + displayName
                });
            }
        });
        
        currentEPG = generateXML(programmes);
        document.getElementById('xmlOutput').textContent = currentEPG;
        showStatus('Initialized ' + programmes.length + ' channels with proper IDs!', 'success');
    } catch (e) {
        showStatus('Error: ' + e.message, 'error');
    }
}

// Generate XML
function generateXML(programmes) {
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<tv>\n';
    
    // Get unique channels
    const channels = new Map();
    programmes.forEach(p => {
        if (!channels.has(p.channel)) {
            channels.set(p.channel, p.displayName || p.channel);
        }
    });
    
    // Add channels
    Array.from(channels.keys()).sort().forEach(id => {
        xml += `  <channel id="${id}">\n`;
        xml += `    <display-name>${channels.get(id)}</display-name>\n`;
        xml += `  </channel>\n`;
    });
    
    // Add programmes
    programmes.sort((a,b) => {
        if (a.channel !== b.channel) return a.channel.localeCompare(b.channel);
        return a.start.localeCompare(b.start);
    }).forEach(p => {
        xml += `  <programme channel="${p.channel}" start="${p.start}" stop="${p.stop}">\n`;
        xml += `    <title>${escapeXML(p.title)}</title>\n`;
        xml += `    <desc>${escapeXML(p.desc)}</desc>\n`;
        xml += `  </programme>\n`;
    });
    
    xml += '</tv>';
    return xml;
}

// Escape XML
function escapeXML(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}

// Parse existing EPG
function parseEPG(xmlStr) {
    const programmes = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlStr, 'text/xml');
    
    // Get display names
    const displayNames = new Map();
    const channels = doc.getElementsByTagName('channel');
    for (let ch of channels) {
        const id = ch.getAttribute('id');
        const dn = ch.getElementsByTagName('display-name')[0];
        if (dn) displayNames.set(id, dn.textContent);
    }
    
    // Get programmes
    const progs = doc.getElementsByTagName('programme');
    for (let prog of progs) {
        const channel = prog.getAttribute('channel');
        programmes.push({
            channel: channel,
            displayName: displayNames.get(channel) || channel,
            start: prog.getAttribute('start'),
            stop: prog.getAttribute('stop'),
            title: prog.getElementsByTagName('title')[0]?.textContent || '',
            desc: prog.getElementsByTagName('desc')[0]?.textContent || ''
        });
    }
    
    return programmes;
}

// Parse date time
function parseDateTime(str) {
    const months = {Jan:0,Feb:1,Mar:2,Apr:3,May:4,Jun:5,Jul:6,Aug:7,Sep:8,Oct:9,Nov:10,Dec:11};
    
    // Sep 22 7:00 PM
    let match = str.match(/(\w+)\s+(\d+)\s+(\d+):(\d+)\s*(AM|PM)/i);
    if (match) {
        const [,mon,day,hr,min,ap] = match;
        let hour = parseInt(hr);
        if (ap.toUpperCase() === 'PM' && hour !== 12) hour += 12;
        if (ap.toUpperCase() === 'AM' && hour === 12) hour = 0;
        return new Date(new Date().getFullYear(), months[mon], parseInt(day), hour, parseInt(min));
    }
    
    // 17:45 22/09
    match = str.match(/(\d+):(\d+)\s+(\d+)\/(\d+)/);
    if (match) {
        const [,hr,min,day,mon] = match;
        return new Date(new Date().getFullYear(), parseInt(mon)-1, parseInt(day), parseInt(hr), parseInt(min));
    }
    
    return null;
}

// Format 12hr time
function format12Hr(date) {
    let h = date.getHours();
    const m = date.getMinutes();
    const ap = h >= 12 ? 'PM' : 'AM';
    h = h % 12 || 12;
    return h + ':' + String(m).padStart(2,'0') + ' ' + ap;
}

// Get sport type
function getSportType(channel) {
    const ch = channel.toLowerCase();
    if (ch.includes('racing') || ch.includes('dirtvision')) return 'racing';
    if (ch.includes('mlb') || ch.includes('baseball')) return 'baseball';
    if (ch.includes('nfl') || ch.includes('football')) return 'football';
    if (ch.includes('nhl') || ch.includes('hockey')) return 'hockey';
    if (ch.includes('nba') || ch.includes('wnba')) return 'basketball';
    if (ch.includes('soccer') || ch.includes('mls') || ch.includes('uefa')) return 'soccer';
    return 'athletic';
}

// Add events to current EPG
function addEvents() {
    try {
        const input = document.getElementById('eventInput').value.trim();
        if (!input) {
            showStatus('Please enter some events', 'error');
            return;
        }
        
        const programmes = currentEPG ? parseEPG(currentEPG) : [];
        const lines = input.split('\n');
        let added = 0;
        
        lines.forEach(line => {
            const match = line.match(/^(.+?)\s*:\s*(.+?)\s*@\s*(.+)$/);
            if (match) {
                const [,ch,event,time] = match;
                const eventTime = parseDateTime(time.trim());
                
                if (eventTime) {
                    // Keep the display name exactly as entered
                    const displayName = ch.trim();
                    const xmlId = displayName.replace(/[\s\-\.]+/g, '');
                    const sport = getSportType(ch);
                    
                    // Event later (8hr before)
                    const laterStart = new Date(eventTime.getTime() - 8.5*3600000);
                    const laterEnd = new Date(eventTime.getTime() - 0.5*3600000);
                    programmes.push({
                        channel: xmlId,
                        displayName: displayName,
                        start: formatDateForXML(laterStart),
                        stop: formatDateForXML(laterEnd),
                        title: 'Event Later Today - ' + event + ' @ ' + format12Hr(eventTime),
                        desc: 'Upcoming: ' + event
                    });
                    
                    // Warmup (30min before)
                    const warmupStart = new Date(eventTime.getTime() - 0.5*3600000);
                    programmes.push({
                        channel: xmlId,
                        displayName: displayName,
                        start: formatDateForXML(warmupStart),
                        stop: formatDateForXML(eventTime),
                        title: sport === 'racing' ? 'Engines Starting, Race Starting Soon' : 'Players Warming Up',
                        desc: 'Pre-game coverage for ' + event
                    });
                    
                    // Main event (3.5hr)
                    const eventEnd = new Date(eventTime.getTime() + 3.5*3600000);
                    programmes.push({
                        channel: xmlId,
                        displayName: displayName,
                        start: formatDateForXML(eventTime),
                        stop: formatDateForXML(eventEnd),
                        title: 'Live: ' + event,
                        desc: 'Live coverage of ' + event
                    });
                    
                    added += 3;
                }
            }
        });
        
        currentEPG = generateXML(programmes);
        document.getElementById('xmlOutput').textContent = currentEPG;
        showStatus('Added ' + added + ' programmes! Total: ' + programmes.length, 'success');
    } catch (e) {
        showStatus('Error: ' + e.message, 'error');
    }
}

// Clear input
function clearInput() {
    document.getElementById('eventInput').value = '';
    showStatus('Input cleared', 'success');
}

// Load from GitHub and continue
async function loadAndAppend() {
    try {
        document.getElementById('saveStatus').innerHTML = '<span class="loading">Loading from GitHub...</span>';
        
        const response = await fetch(
            'https://api.github.com/repos/' + GITHUB_REPO + '/contents/' + GITHUB_FILE,
            { headers: { 'Accept': 'application/vnd.github.v3+json' } }
        );
        
        if (response.ok) {
            const data = await response.json();
            currentEPG = atob(data.content);
            document.getElementById('xmlOutput').textContent = currentEPG;
            const progs = parseEPG(currentEPG);
            document.getElementById('saveStatus').innerHTML = '';
            showStatus('Loaded ' + progs.length + ' programmes from GitHub! Ready to add more.', 'success');
        } else {
            document.getElementById('saveStatus').innerHTML = '';
            showStatus('No existing file on GitHub. Starting fresh.', 'info');
            initChannels();
        }
    } catch (e) {
        document.getElementById('saveStatus').innerHTML = '';
        showStatus('Error loading: ' + e.message, 'error');
    }
}

// Purge old
function purgeOld() {
    try {
        if (!currentEPG) {
            showStatus('No data to purge', 'error');
            return;
        }
        
        if (!confirm('Remove programmes older than 7 days?')) return;
        
        const programmes = parseEPG(currentEPG);
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - 7);
        
        const before = programmes.length;
        const filtered = programmes.filter(p => parseXMLDate(p.stop) > cutoff);
        
        currentEPG = generateXML(filtered);
        document.getElementById('xmlOutput').textContent = currentEPG;
        showStatus('Removed ' + (before - filtered.length) + ' old programmes', 'success');
    } catch (e) {
        showStatus('Error: ' + e.message, 'error');
    }
}

// Clear all
function clearAll() {
    if (!currentEPG) {
        showStatus('No data to clear', 'error');
        return;
    }
    
    if (confirm('Clear ALL data?')) {
        currentEPG = null;
        document.getElementById('xmlOutput').textContent = 'No EPG generated yet. Click "Initialize Fresh Channels" or "Load & Continue" to start.';
        document.getElementById('eventInput').value = '';
        document.getElementById('stats').style.display = 'none';
        showStatus('All data cleared!', 'success');
    }
}

// Show statistics
function showStatistics() {
    try {
        if (!currentEPG) {
            showStatus('No data to analyze', 'error');
            return;
        }
        
        const programmes = parseEPG(currentEPG);
        const channels = new Set(programmes.map(p => p.channel));
        const now = new Date();
        
        const stats = {
            channels: channels.size,
            total: programmes.length,
            live: programmes.filter(p => parseXMLDate(p.start) <= now && parseXMLDate(p.stop) >= now).length,
            upcoming: programmes.filter(p => parseXMLDate(p.start) > now).length,
            past: programmes.filter(p => parseXMLDate(p.stop) < now).length
        };
        
        const statsDiv = document.getElementById('stats');
        statsDiv.innerHTML = `
            <div class="stat-card"><h4>Channels</h4><p>${stats.channels}</p></div>
            <div class="stat-card"><h4>Total</h4><p>${stats.total}</p></div>
            <div class="stat-card"><h4>Live</h4><p>${stats.live}</p></div>
            <div class="stat-card"><h4>Upcoming</h4><p>${stats.upcoming}</p></div>
            <div class="stat-card"><h4>Past</h4><p>${stats.past}</p></div>
        `;
        statsDiv.style.display = 'grid';
    } catch (e) {
        showStatus('Error: ' + e.message, 'error');
    }
}

// Save token
function saveToken() {
    const token = document.getElementById('githubToken').value.trim();
    if (token) {
        localStorage.setItem('githubToken', token);
        showStatus('Token saved locally!', 'success');
    } else {
        showStatus('Please enter a token', 'error');
    }
}

// Save to GitHub (always loads existing first, then saves)
async function saveToGitHub() {
    try {
        const token = document.getElementById('githubToken').value.trim();
        if (!token) {
            showStatus('Please enter GitHub token first', 'error');
            return;
        }
        
        if (!currentEPG) {
            showStatus('No EPG to save', 'error');
            return;
        }
        
        document.getElementById('saveStatus').innerHTML = '<span class="loading">Saving to GitHub...</span>';
        
        // Get current SHA if exists
        let sha = null;
        try {
            const getResp = await fetch(
                'https://api.github.com/repos/' + GITHUB_REPO + '/contents/' + GITHUB_FILE,
                {
                    headers: {
                        'Authorization': 'token ' + token,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                }
            );
            if (getResp.ok) {
                const data = await getResp.json();
                sha = data.sha;
            }
        } catch (e) {}
        
        // Save file
        const body = {
            message: 'Update EPG - ' + new Date().toLocaleString(),
            content: btoa(unescape(encodeURIComponent(currentEPG)))
        };
        if (sha) body.sha = sha;
        
        const response = await fetch(
            'https://api.github.com/repos/' + GITHUB_REPO + '/contents/' + GITHUB_FILE,
            {
                method: 'PUT',
                headers: {
                    'Authorization': 'token ' + token,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            }
        );
        
        if (response.ok) {
            document.getElementById('saveStatus').innerHTML = '‚úÖ Saved successfully!';
            showStatus('Saved to GitHub successfully!', 'success');
            setTimeout(() => {
                document.getElementById('saveStatus').innerHTML = '';
            }, 3000);
        } else {
            const error = await response.text();
            document.getElementById('saveStatus').innerHTML = '‚ùå Save failed';
            showStatus('GitHub error: ' + error, 'error');
            setTimeout(() => {
                document.getElementById('saveStatus').innerHTML = '';
            }, 5000);
        }
    } catch (e) {
        document.getElementById('saveStatus').innerHTML = '‚ùå Save failed';
        showStatus('Error: ' + e.message, 'error');
        setTimeout(() => {
            document.getElementById('saveStatus').innerHTML = '';
        }, 5000);
    }
}

// Download XML
function downloadXML() {
    if (!currentEPG) {
        showStatus('No EPG to download', 'error');
        return;
    }
    
    const blob = new Blob([currentEPG], {type: 'text/xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'KTV_EPG_Events-all.xml';
    a.click();
    URL.revokeObjectURL(url);
    showStatus('Downloaded!', 'success');
}
</script>
</body>
</html>
